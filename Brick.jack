class Brick {

    field int xPos;
    field int yPos;
    field int length;
    field int height;
    field int requiredHitAmount;
    field int currentHitAmount;
    field boolean isDestroyed;
    field Bonus bonus;
    field Platform platform;
    field Array balls;

    constructor Brick new(int x, int y, int l, int h, int hits, Array bs, Platform p) {
        var int value;
        let xPos = x;
        let yPos = y;
        let length = l;
        let height = h;
        let requiredHitAmount = hits;
        let balls = bs;
        let platform = p;
        let value = Random.range(1, 10);
        if (value > 9) {
            let bonus = Bonus.new((xPos + (length / 2)), yPos, platform);
        }
        do draw();
        return this;
    }

    method void erase() {
        do Screen.setColor(false);
        do Screen.drawRectangle(xPos, yPos, xPos + length, yPos + height);
        do Screen.setColor(true);
        return;
    }

    method void dispose() {
        if (~(bonus = null)) {
            do bonus.dispose();
        }
        do Memory.deAlloc(this);
        return;
    }

    method void draw() {
        do Screen.drawRectangle(xPos, yPos, xPos + length, yPos + height);
        return;
    }

    method void checkCollisionWithBalls() {
        var int ballX, ballY, ballLeft, ballRight, ballUp, ballDown, counter, ballsCount;
        var Ball ball;
        let ballsCount = platform.getBallsCount();
        while (~(counter = ballsCount)) {
            let ball = balls[counter];
            let ballX = ball.getCenterX();
            let ballY = ball.getCenterY();
            let ballLeft = ball.getLeft();
            let ballRight = ball.getRight();
            let ballUp = ball.getUp();
            let ballDown = ball.getDown();
            if ((ballX > xPos) & (ballX < (xPos + length)) & (ballUp < (yPos + height)) & (ballUp > yPos)) {
                let currentHitAmount = currentHitAmount + 1;
                do ball.applyBrickCollision(1, -1);
            }
            if ((ballX > xPos) & (ballX < (xPos + length)) & (ballDown > yPos) & (ballDown < (yPos + height))) {
                let currentHitAmount = currentHitAmount + 1;
                do ball.applyBrickCollision(1, -1);
            }
            if ((ballY > yPos) & (ballY < (yPos + height)) & (ballLeft < (xPos + length)) & (ballLeft > xPos)) {
                let currentHitAmount = currentHitAmount + 1;
                do ball.applyBrickCollision(-1, 1);
            }
            if ((ballY > yPos) & (ballY < (yPos + height)) & (ballRight > xPos) & (ballRight < (xPos + length))) {
                let currentHitAmount = currentHitAmount + 1;
                do ball.applyBrickCollision(-1, 1);
            }
            let counter = counter + 1;
        }
        return;
    }

    method void update() {
        if (isDestroyed) {
         if (~(bonus = null)) {
            do bonus.update();
         }
         return;
        }
        do checkCollisionWithBalls();
        if ((currentHitAmount = requiredHitAmount) | (currentHitAmount > requiredHitAmount)) {
            let isDestroyed = true;
            do bonus.onBrickDestroy();
            do erase();
            return;
        }
        do draw();
        return;
    }

    method boolean gotDestroyed() {
        return isDestroyed;
    }
}
